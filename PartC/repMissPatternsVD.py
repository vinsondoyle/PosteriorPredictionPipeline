#!/usr/bin/env python

import sys
import os
import subprocess
import re

# ----> User-Defined Options <----

if len(sys.argv) ==1:
	print 'you need the filename as an argument'
	sys.exit(-1)
else:
	empDatName = sys.argv[1]

#empDatName = "primates.nex"		# The name of the empirical data set with missing data

# ---> Defining some functions of convenience <---

def shCall( cmd ):
	subprocess.call(cmd,shell=True)
	
def cd( cmd ):
	os.chdir(cmd)
	
def ls( ):
	files = os.listdir(".")
	if (files[0] == ".DS_Store"):
		files = files[1:] # To get rid of .DS_Store
	return files

def findAllPos( string,sub ):	# Only works for non-overlapping substrings
	return [match.start() for match in re.finditer(sub,string)]
	
def findMissPos( nexFile ):
	inFile = open(nexFile,'r')
	parLine = inFile.readline()
	while ( 'matrix' not in parLine ):
		parLine = inFile.readline()
	matrixLine = inFile.readline()
	while not matrixLine.strip():
		matrixLine = inFile.readline()
	missPos = []
	while ( ';' not in matrixLine ):
		matrixLine = matrixLine.split()[1]
		gaps = findAllPos(matrixLine,'-')
		ambigs = findAllPos(matrixLine,'N')
		miss = findAllPos(matrixLine,'\?')
		gaps.extend(ambigs)
		gaps.extend(miss)
		gaps = sorted(gaps)
		missPos.append(gaps)
		matrixLine = inFile.readline()
	inFile.close()
	return missPos

def getNexHeader( nexFile ):
	"""
	Function to read in and store lines of original nexus file above data matrix
	"""
	nexHeader = []
	nexIn = open(nexFile,'r')
	readFile = nexIn.read()
	for line in readFile.splitlines(True):
		if "nexus" in line:
			nexHeader.append(line)
		if "NEXUS" in line:
			nexHeader.append(line)
		if "begin data" in line:
			nexHeader.append(line)
		if "dimensions" in line:
			nexHeader.append(line)
		if "format" in line:
			nexHeader.append(line)
		if "matrix" in line:
			nexHeader.append(line)
	nexIn.close()
	return nexHeader
	
def readMatrix( inStream ):
	"""
	Function to read in simulated sequences from a .dat file generated by seq-gen.
	Sequences are ordered by taxon number.
	"""
	inStream.readline() # Gets rid of phylip header line
	seqDict = {}
	seqs = []
	seqLine = inStream.readline()
	seqLine = seqLine.split()
	while ( len(seqLine) > 1 ):	# Reads in seqs from file and stores in dict with tax # key
		seqDict[int(seqLine[0])] = seqLine[1]
		seqLine = inStream.readline()
		seqLine = seqLine.split()
	for i in range(len(seqDict)):
		seqs.append(seqDict[i+1])
	return seqs
	
def getTaxNames( nexFile ):
	nexIn = open(nexFile,'r')
	parLine = nexIn.readline()
	while ( 'matrix' not in parLine ):
		parLine = nexIn.readline()
	name = nexIn.readline()
	while not name.strip():
		name = nexIn.readline()
	name = name.split()
	taxa = []
	while( ";" not in name ):
		taxa.append(name[0])
		name = nexIn.readline()
		name = name.split()
	return taxa
	
def outputMatrixWithMiss( outStream,header,taxa,seqs,miss ):
	for i in nexHeader:
		outStream.write( i )
	if ( len(taxa) != len(seqs) ):
		sys.exit("Number of taxon names different than number of simulated sequences! Exiting...")
	if ( len(taxa) != len(miss) ):
		sys.exit("Number of taxon names different than number of missing position lists! Exiting...")
	# Add missing data to sequences
	for i in range( len(miss) ):
		for j in miss[i]:
			seqList = list(seqs[i])
			seqList[j] = "-"
			seqs[i] = "".join(seqList)
	# Output taxon names and sequences to file
	for i in range( len(taxa) ):
		outStream.write( "%s		%s\n" % (taxa[i],seqs[i]) )
	outStream.write(";\n")
	outStream.write("End;\n")
	
# ---> End function definitions <---
	
shCall("mkdir SeqOutfiles_wMiss")
miss = findMissPos("%s" % empDatName)
nexHeader = getNexHeader("%s" % empDatName)
taxNames = getTaxNames("%s" % empDatName)
cd("SeqOutfiles")
dats = ls()
for j in dats:
	datIn = open(j,'r')
	datFileRootIn = subprocess.Popen("basename %s .dat" % j,shell=True,stdout=subprocess.PIPE)
	datFileRoot = datFileRootIn.communicate()[0].strip()
	nexOut = open("../SeqOutfiles_wMiss/%s.nex" % datFileRoot,'w')	
	matrix = readMatrix(datIn)	# Reads in data matrix and orders taxa by number
	outputMatrixWithMiss(nexOut,nexHeader,taxNames,matrix,miss)
	datIn.close()
	nexOut.close()
cd("..") # Back out of SeqOutfiles
	